#if NET40 || NET45 || NET451 || NET452 || NET46 || NET461 || NET462 || NET47 || NET471 || NET472
#define NET_LEAST_4_0
#endif

#if NETCOREAPP1_0 || NETCOREAPP1_1
#define NETCOREAPP_BELOW_2_0
#define NETCOREAPP_LEAST_1_0
#endif

#if NETSTANDARD2_0 || NETCOREAPP_2_0 || NETCOREAPP2_1 || NETCOREAPP2_2
#define NETCOREAPP_LEAST_2_0
#define NETCOREAPP_LEAST_1_0
#endif

// NOTE: NETSTANDARD_X flags are set specifically if .NET Standard or .NET core is targeted instead of .NET Framework
#if NETSTANDARD1_0 || NETSTANDARD1_1 || NETSTANDARD1_2 || NETSTANDARD1_3 || NETSTANDARD1_4 || NETSTANDARD1_5 || NETSTANDARD1_6 || NETCOREAPP_BELOW_2_0
#define NETSTANDARD_BELOW_2_0
#define NETSTANDARD_LEAST_1_0
#endif

#if NETSTANDARD2_0 || NETCOREAPP_LEAST_2_0
#define NETSTANDARD_LEAST_2_0
#define NETSTANDARD_LEAST_1_0
#endif

#if NETSTANDARD_LEAST_2_0 || NET_LEAST_4_0
#define HAS_CONTRACTS
#endif

// "Unreachable code detected"
#pragma warning disable 162

//////////////////////////////////////////////////////////////////////////////

using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Runtime.InteropServices;
using RTMath.Utilities.ResourceLoaderUtils;
using RTMath.ZStd;

#if HAS_CONTRACTS
using System.Diagnostics.Contracts;
#endif


namespace RTMath.Utilities
{
	using static ResourceLoaderUtils.Logger;
	using static ResourceLoaderUtils.Util;
	using FileStream = ResourceLoaderUtils.FileStream;

	/// <summary>
	/// Dummy interfaces to enable some syntactic sugar.
	/// This is a bit excessive but I'm asked to disallow Load() call without _both_ From() and To() on compile time
	/// </summary>
	/// 

	/// <summary>
	/// Base ResourceLoader instance. Only supports limited set of operations
	/// </summary>
	/// 
	internal interface IResourceLoaderBase
	{
		string ActualDeploymentPath { get; }
		string ActualResourcePath { get; }
	}

	internal interface IResourceLoaderDone : IResourceLoaderBase
	{
		/// <summary>
		/// Decrement reference count for all loaded dynamic libraries
		/// </summary>
		/// <returns></returns>
		IResourceLoaderDone UnloadDlls();
	}

	internal interface IResourceLoaderInstance : IResourceLoaderBase
	{
		IResourceLoaderInstance AlwaysOverwrite(bool alwaysOverwrite);

		/// <summary>
		/// <para/>By default, we only reuse the existing files if all were already found in the target directory and try to create or overwrite all the files otherwise
		/// <para/>If some but not all files are found, enable reuse of existing files without trying to overwrite them while only deploying the missing ones.
		/// <para/>This is a dangerous behavior which is disabled by default. This option does not imply file contents verification.
		/// </summary>
		/// <param name="reuseEnabled">Enable reuse of partially deployed fileset</param>
		/// <returns></returns>
		IResourceLoaderInstance ReusePartiallyDeployed(bool reuseEnabled);

		/// <summary>
		/// <para/>If an absolute deployment path is given, and it we failed to deploy at that location,
		/// try to use an alternative deployment path generated by concatenating a random subdirectory name with the specified path
		/// </summary>
		/// <param name="enable">If true, use a subdirectory with random name as fallback
		/// <para/>false by default</param>
		/// 
		/// <returns>Instance of initialized ResourceLoader, user can still specify optional parameters before calling .Load()</returns>
		IResourceLoaderInstance TryRandomFallbackSubDirectory(bool enable);

		IResourceLoaderInstance AddDllSuffix(string libraryNameSuffix);
		IResourceLoaderInstance RetryTimeout(int millis);

		/// <summary>
		/// Control if unpacked dynamic libraries should be loaded
		/// </summary>
		/// <param name="shouldLoadDlls"> Load dlls. true by default</param>
		/// <returns>Same instance</returns>
		IResourceLoaderInstance ShouldLoadDlls(bool shouldLoadDlls);

		IResourceLoaderDone Load();
	}

	internal interface IResourceLoaderInstanceFrom
	{
		/// <summary>
		/// Set deployment path template. Resource files will be deployed at the path generated from this template.
		/// If the path, after expansion, is absolute, it is used as-is and exception is thrown on deployment failure.
		/// If the path is relative, several deployment root paths may be tried before reporting failure.
		/// The following variables will be substituted:
		/// <list>
		/// <item>$(OS) => 'Windows' | 'Linux' | 'OSX' - name of the current OS platform</item>
		/// <item>$(VERSION) => current assembly name in the form of 'X.X.X.X'</item>
		/// <item>$(ARCH) => '32' | '64' - pointer size on the current architecture</item>
		/// <item>$(DLLEXT) => 'dll' | 'so' | 'dylib' - dynamic library file extension for the current OS platform</item>
		/// <item>$(TEMP) => Temporary directory for the current user</item>
		/// <item>$(RANDOM) => random 8-digit hexadecimal string</item>
		/// <item>$(COMMONAPPDATA) => shared application data directory, not available on older .NET platforms</item>
		/// <item>$(LOCALAPPDATA) => local current user's application data, not available on older .NET platforms</item>
		/// </list>
		/// </summary>
		/// <param name="deploymentRelativePathTemplate"></param>
		/// <returns>Instance of partially initialized ResourceLoader, call .From() to set resource search mask</returns>
		IResourceLoaderInstance To(string deploymentRelativePathTemplate);
	}

	internal interface IResourceLoaderInstanceTo
	{
		IResourceLoaderInstance From(string deploymentRelativePathTemplate);
		IResourceLoaderInstance From(Assembly assembly, string deploymentRelativePathTemplate);
	}

	internal class ResourceLoader : IResourceLoaderInstance, IResourceLoaderInstanceFrom, IResourceLoaderInstanceTo,
		IResourceLoaderDone
	{
		// OS Abstraction
		internal class OS
		{
			const int Windows = 0;
			const int Linux = 1;
			const int Osx = 2;

			public static readonly bool Is64 = 8 == IntPtr.Size;

			public static string Name => _osName[_os];

			public static bool IsWindows => Windows == _os;
			public static bool IsLinux => Linux == _os;
			public static bool IsOsx => Osx == _os;
			public static bool IsUnix => Windows != _os;

			public static bool IsDllExt(string ext) => DllExt.Equals(ext);
			public static string DllExt => _dllExt[_os];

			private static readonly int _os;
			private static readonly string[] _osName = { "Windows", "Linux", "OSX" };
			private static readonly string[] _dllExt = { ".dll", ".so", ".dylib" };

// Needed only for .NET Framework (Actually called on Mono + Unix OS-es)
#if !NETSTANDARD_LEAST_1_0 && !NETCOREAPP_LEAST_1_0
			private static string ReadProcessOutput(string name, string args = "")
			{
				try {
					var startInfo = new ProcessStartInfo(name, args);
					startInfo.UseShellExecute = false;
					startInfo.RedirectStandardOutput = true;
					var p = Process.Start(startInfo);
					string output = p.StandardOutput.ReadToEnd();
					p.WaitForExit();
					return output == null ? "" : output.Trim();
				} catch {
					return "";
				}
			}
#endif

			/// <summary>
			/// See the
			/// https://apisof.net/catalog/System.Runtime.InteropServices.RuntimeInformation.IsOSPlatform(OSPlatform)
			/// https://docs.microsoft.com/ru-ru/dotnet/api/system.environment.osversion?redirectedfrom=MSDN&amp;view=netframework-4.7.2#System_Environment_OSVersion
			/// http://mono.wikia.com/wiki/Detecting_the_execution_platform
			/// </summary>
			/// <returns>Internal enum</returns>
			private static int DetectOs()
			{
				/* Need 1.1 actually, but good enough.. */
#if NETSTANDARD_LEAST_1_0 || NETCOREAPP_LEAST_1_0
				return RuntimeInformation.IsOSPlatform(OSPlatform.Windows) ? Windows :
					RuntimeInformation.IsOSPlatform(OSPlatform.OSX) ? Osx :
					RuntimeInformation.IsOSPlatform(OSPlatform.Linux) ? Linux : -1;
#else
				// .NET std/core >= 2.0 supports both methods
				int p = (int)Environment.OSVersion.Platform;
				return
					p < 4 ? Windows :
					/* Old Mac OS value */ p == 6 ? Osx :
					/* Any Unix */ p == 4 || p == 128 ? (ReadProcessOutput("uname").Contains("Darwin") ? Osx : Linux)
					: -1;
#endif
#if _REMOVED_47363525_
									// Additional OS detection code (unused)
									String windir = Environment.GetEnvironmentVariable("windir");
									if (!String.IsNullOrEmpty(windir) && windir.Contains(@"\") && Directory.Exists(windir)) { }
										return Windows;
									else if (File.Exists(@"/proc/sys/kernel/ostype") && File.ReadAllText(@"/proc/sys/kernel/ostype")
											 .StartsWith("Linux", StringComparison.OrdinalIgnoreCase))
										return Linux;

#endif
			}

			public static Assembly CurrentAssembly
			{
				get
				{
#if NETSTANDARD_LEAST_1_0
					return typeof(ResourceLoader).GetTypeInfo().Assembly;
#else
					return typeof(ResourceLoader).Assembly;
#endif
					//return Assembly.GetExecutingAssembly();
				}
			}

			public static string GetVersion(Assembly assembly)
			{
#if NETSTANDARD2_0
				return assembly.CustomAttributes
					.Where(x => x.AttributeType == typeof(AssemblyFileVersionAttribute))
					.First().ConstructorArguments.First().Value.ToString();
#else
				return assembly.GetName().Version.ToString();
#endif
			}

			public static string AssemblyVersion => GetVersion(CurrentAssembly);

			static OS()
			{
				if ((_os = DetectOs()) < 0)
					throw new InvalidProgramException("Current OS platform is not supported.");
			}

			public static void Sleep(int millis)
			{
#if NETSTANDARD_BELOW_2_0 && !NETCOREAPP_LEAST_1_0
				System.Threading.Tasks.Task.Delay(millis).Wait();
#else
				System.Threading.Thread.Sleep(millis);
#endif
			}

			internal static IntPtr LoadNativeLibrary(string filePath, bool lazyResolution = false)
			{
				if (IsWindows)
					return LoadLibrary(filePath);

				// Linux/OSX distinction will probably be removed from here
				DlOpenFlags dlOpenFlags = DlOpenFlags.RTLD_GLOBAL
					| (lazyResolution ? DlOpenFlags.RTLD_LAZY : DlOpenFlags.RTLD_NOW);

				// NOTE: Instantiate dlerror in advance, otherwise 1st call will erase the error message!
				if (IsLinux)
					dlerror();
				else
					dlerrorOSX();

				IntPtr handle = IsLinux
					? dlopen(filePath, (int)dlOpenFlags)
					: dlopenOSX(filePath, (int)dlOpenFlags);

				if (Logger.LogLevelLeast(DBG))
					Log($"IsLinux: {IsLinux} Flags: {dlOpenFlags} Handle: {handle} Error: {dlerror()}");

				return handle;
			}

			internal static bool UnloadNativeLibrary(IntPtr handle)
			{
				if (Logger.LogLevelLeast(DBG))
					Log($"Unload {handle}");

				return IsWindows
					? 0 != FreeLibrary(handle)
					: 0 == (IsLinux ? dlclose(handle) : dlcloseOSX(handle));
			}

			internal static string LastDlErrorText()
			{
				if (IsWindows)
				{
					var ex = new Win32Exception();
					return $"{ex.NativeErrorCode:X}/{ex.NativeErrorCode} : {ex.Message}";
				}

				IntPtr err = IsLinux ? dlerror() : dlerrorOSX();
				return IntPtr.Zero == err ? "NULL" : Marshal.PtrToStringAnsi(err);
			}

			[DllImport("kernel32", CharSet = CharSet.Unicode, SetLastError = true)]
			private static extern IntPtr LoadLibrary([In] string lpFileName);

			[DllImport("kernel32", SetLastError = true)]
			private static extern int FreeLibrary(IntPtr handle);

			// TODO: Is versioned name really necessary here? This creates problems with OSX support
			[DllImport("libdl.so.2", CharSet = CharSet.Ansi)]
			private static extern IntPtr dlopen(String fileName, int flags);

			[DllImport("libdl.so.2")]
			private static extern IntPtr dlerror();

			[DllImport("libdl.so.2")]
			private static extern int dlclose(IntPtr handle);

			[DllImport("libdl.dylib", EntryPoint = "dlopen", CharSet = CharSet.Ansi)]
			private static extern IntPtr dlopenOSX(String fileName, int flags);

			[DllImport("libdl.dylib", EntryPoint = "dlerror", CharSet = CharSet.Ansi)]
			private static extern IntPtr dlerrorOSX();

			[DllImport("libdl.dylib", EntryPoint = "dlclose", CharSet = CharSet.Ansi)]
			private static extern int dlcloseOSX(IntPtr handle);

			[Flags]
			private enum DlOpenFlags : int
			{
				RTLD_LAZY = 0x00001,
				RTLD_NOW = 0x00002,
				RTLD_NOLOAD = 0x00004,
				RTLD_DEEPBIND = 0x00008,
				RTLD_GLOBAL = 0x00100,
				RTLD_LOCAL = 0,
				RTLD_NODELETE = 0x01000
			}
		}

		// String Template
		protected class TemplateString
		{
			// We are going to have an extensive error reporting for malformed templates, just in case..
			public static string Verify(string substituted)
			{
				int iStart = substituted.IndexOf("$(", StringComparison.Ordinal);
				if (iStart >= 0)
				{
					int iEnd = substituted.IndexOf(")", iStart, StringComparison.Ordinal);
					int iStart2 = substituted.IndexOf("$(", iStart + 1, StringComparison.Ordinal);
					throw new ArgumentException(String.Format("Template substitution error: {0} at position {1}: {2}",
						iEnd < 0 || iStart2 <= iEnd ? "Key not terminated" : "Unknown/unexpected key",
						iStart, substituted.Substring(iStart)));
				}

				return substituted;
			}

			private static string Substitute1(string template, string key, string value)
			{
				return template.Replace("$(" + key + ')', value);
			}

			private static bool ContainsKey(string template, string key)
			{
				return template.IndexOf("$(" + key + ')', StringComparison.Ordinal) >= 0;
			}

			private static bool ContainsKey(string template, params string[] keys)
			{
				foreach (var key in keys)
					if (ContainsKey(template, key))
						return true;

				return false;
			}

			public static string Substitute(string template, params string[] keyValuePairs)
			{
				int n = keyValuePairs.Length;
				if (0 != (n & 1))
					throw new ArgumentException("kvps.Length must be odd value", "keyValuePairs");

				for (int i = 0; i < n; i += 2)
					template = Substitute1(template, keyValuePairs[i], keyValuePairs[i + 1]);

				return template;
			}
		}

		private class Resource : IDisposable, IComparable
		{
			public readonly string ResourcePath;	// Full resource path
			public readonly string Name;			// Original resource filename, without path
			public readonly string Filename;		// Filename only for the deployed resource.

			public readonly bool IsZstd;			// Needs decompression from ZStd
			public readonly bool IsDll;

			public readonly int  Length;
			public readonly int  Order;

			private FileStream _fileStream;
			internal IntPtr DlHandle;

			public Resource(string resourcePath, int commonNamePrefixLength, int initialOrder, ResourceLoader owner)
			{
				this.ResourcePath = resourcePath;
				var tags = new Dictionary<String,String>();
				String filename = this.Name = GetTags(resourcePath.Substring(commonNamePrefixLength), tags)
									.Replace('_', '.');
				this.IsZstd = filename.EndsWith(".zst");
				if (IsZstd)
					filename = filename.Substring(0, filename.Length - 4);

				// Owner can optionally rename the resource
				this.Filename = filename = owner.TryRenameResource(filename);
				this.IsDll = filename.EndsWith(OS.DllExt);

				// Parse file order tags
				this.Order = initialOrder;
				foreach (var kv in tags)
				{
					String key = kv.Key;
					String value = kv.Value;
					if (key.Equals("order"))
					{
						int order;
						if (!Int32.TryParse(value, out order) || order < 0)
							throw new ArgumentException(
								$"Order tag invalid, non-negative integer expected: [order@{value}]");

						this.Order = order + int.MinValue; // Needed to combine natural order and explicit order
					}
					else
						throw new ArgumentException($"Invalid Tag: [{key}@{value}]");
				}

				// Try to open. Record resource length
				using (var resourceStream = owner.ResourceAssembly.GetManifestResourceStream(resourcePath))
				{
					if (null == resourceStream)
						throw new Exception($"Resource file not found: {resourcePath}");

					long length = resourceStream.Length;
					if (length > int.MaxValue)
						throw new Exception($"Resource file length is too big: {length}");

					this.Length = (int) length;
				}

				owner.ResourceAdded(this);
			}

			internal string FullPath(string deploymentPath) => Path.Combine(deploymentPath, Filename);

			internal FileStream MoveFileHandle()
			{
				var fs = _fileStream;
				_fileStream = null;
				return fs;
			}

			internal FileStream File
			{
				get { return _fileStream; }
				set
				{
					if (value != _fileStream)
					{
						_fileStream?.Dispose();
						_fileStream = value;
					}
				}
			}

#region IDisposable Support

			public void Dispose()
			{
				File = null;
			}

			internal void ReadLock(string filePath)
			{
				this.File = new FileStream(filePath, FileMode.Open, FileAccess.Read, FileShare.Read,
					0x1000 /*tiny buffer*/);
			}

#endregion

			// Natural order returned by this comparator is used as LoadLibrary order
			public int CompareTo(object other)
			{
				return this.Order.CompareTo(((Resource)other).Order);
			}
		}

		public Exception
			LastDeploymentException { get; private set; } // Last exception thrown during resource deployment

		/// <summary>
		///  Deployment options for this fileset
		/// </summary>
		[Flags]
		protected enum Opt
		{
			AlwaysOverwrite = 1,
			VerifyLength = 4,
			VerifyContent = 8,
			ReusePartiallyDeployed = 16,
			KeepDllsLocked = 32
		}

		private const string RandomDirRegEx = "^[0-9a-fA-F]{4,8}$";
		private const int ReadWriteBlockSize = 1 << 24;

		private static readonly List<FileStream> LockedDlls = !OS.IsWindows ? new List<FileStream>() : null;
		private static readonly Random _rnd;

		private readonly Diagnostics _diag;

		private Assembly _assembly;             // The assembly containing the resources

		// User-settable config flags
		private Opt _deploymentOptions;
		private bool _addRandomFallbackSubDirectory;
		private bool _shouldLoadDlls = true;

		// User-configurable paths
		private string _resourcePathTemplate;
		private string _deploymentPathTemplate;
		private string _libraryNameSuffix;      // Optional dynamic library name suffix

		// Derived paths
		private string _resourcePrefix, _resourceSuffix;    // Parts of the resource name glob mask

		// After-deployment paths
		private string _lastUsedPath;			// Last path used for deployment
		private string _lastSuccessfulPath;		// Last path used for _successful_ deployment
		
		// Multiprocess/multithread deployment path contention management
		private FileStream _lockFile;			// Lock file created during write operations
		private int _retryTimeoutMs;			// User-configurable
		private int _lockUpdatePeriodMs;	
		private int _lockLastUpdateMs;

		private FileStream LockFile
		{
			get { return _lockFile; }
			set
			{
				if (value != _lockFile)
				{
					_lockFile?.Dispose();

					if (null == value)
						Dbg("last.unlockedAt", DateTime.Now);

					Log($"LockFile: {(value != null ? "Acquired" : "Released")}");
					_lockFile = value;
				}
			}
		}

		// Resource set
		private List<Resource> _resources;
		private long _maxResourceLength;    // Maximum size of a resource file (before decompression)
		private long _totalResourceLength;  // Total size of deployed data (before decompression)
		private int _dlCount;               // Number of Dynamic Libraries in the fileset

		// Buffer for the data read from resources. As big as the biggest resource.
		private byte[] _inputBuffer;
		// Buffer for the data decompressed from resources. Dynamically reallocated to be big enough to hold zstd-decoded data.
		// Not allocated if there is no ZStd compression
		private byte[] _outputBuffer;

		static ResourceLoader()
		{
			var buffer = new byte[4];
			// NOTE: We can't save the returned value of Create() call as a field, because its type differs between .NET frameworks
			System.Security.Cryptography.RandomNumberGenerator.Create().GetBytes(buffer);
			_rnd = new Random(BitConverter.ToInt32(buffer, 0));
			String dbgCfg = Environment.GetEnvironmentVariable("NATIVEUTILS_RL_DEBUG");
			try
			{
				Logger.SetLogLevel(Int32.Parse(dbgCfg));
			}
			catch
			{
			}
		}

		private ResourceLoader()
		{
			_diag = new Diagnostics();
			_retryTimeoutMs = -1;		// -1 means "Auto", will be set depending on data size
		}

		private void Dbg(String key, Object value) => _diag?.Add(key, value);

		private void DbgClear(String key) => _diag?.Clear(key);

		private void DbgLast(String key, Object value)
		{
			if (null != _diag)
			{
				Dbg("last." + key, value);
				Dbg("dep." + key, value);
			}
		}

		// Helper static constructor
		private static ResourceLoader NewInstance()
		{
			return new ResourceLoader();
		}

		private static string ApplyBasicTemplateNoVerify(string template, Assembly assembly)
		{
			return TemplateString.Substitute(template
				, "DLLEXT", OS.DllExt.Substring(1) /* Without dot */
				, "OS", OS.Name
				, "ARCH", OS.Is64 ? "64" : "32"
				, "VERSION", OS.GetVersion(assembly ?? OS.CurrentAssembly)
				);
		}

		private static string ApplyBasicTemplate(string template, Assembly assembly = null)
		{
			return TemplateString.Verify(ApplyBasicTemplateNoVerify(template, assembly));
		}


		private static string ApplyPathTemplate(string template, Assembly assembly = null)
		{
			var str = TemplateString.Substitute(ApplyBasicTemplateNoVerify(template, assembly)
				, "RANDOM", Path.DirectorySeparatorChar + NextRandomDirString()
#if !NETSTANDARD_BELOW_2_0
				, "COMMONAPPDATA", Environment.GetFolderPath(Environment.SpecialFolder.CommonApplicationData)
				, "LOCALAPPDATA", Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData)
#endif
				, "TEMP", Path.GetTempPath()
				);

			return TemplateString.Verify(str);
		}


		private static int Rnd()
		{
			lock (_rnd)
			{
				return _rnd.Next();
			}
		}


		private static string NextRandomDirString() => Rnd().ToString("x");


		private static int RandomSleep(int limit)
		{
			int millis = (Rnd() & 0x3F) + 0x20;
			millis = Math.Min(millis, Math.Max(limit, 1));
			OS.Sleep(millis);
			return millis;
		}


		private byte[] InputBuffer
		{
			get { return _inputBuffer = _inputBuffer ?? new byte[_maxResourceLength]; }
		}

		/// <summary>
		/// Optionally rename the resource file before it is written to disk. 
		/// We can add logic here that changes filenames for some purpose
		/// Future impl will probably allow us to use Regexp
		/// </summary>
		/// <param name="filename">filename of the resource file without path component that will be used for saving it to disk</param>
		/// <returns>new filename for the resource</returns>
		private string TryRenameResource(string filename)
		{
			int lastDotIndex = filename.LastIndexOf('.');
			string ext;
			// Is a dynamic library? Rename, if new suffix is specified
			if (lastDotIndex >= 0 && OS.IsDllExt(ext = filename.Substring(lastDotIndex)) && null != _libraryNameSuffix)
			{
				// Append new extension to the library file name
				filename = filename.Substring(0, lastDotIndex) + _libraryNameSuffix + ext;
			}

			return filename;
		}

		private void LockFileWatchdogInit()
		{
			_lockLastUpdateMs = Environment.TickCount - _lockUpdatePeriodMs;
		}

		private void LockFileWatchdogUpdate() => LockFileWatchdogUpdate(false);

		void LockFileWatchdogUpdate(bool force)
		{
			int now = Environment.TickCount;
			Int32 elapsed = now - _lockLastUpdateMs;
			//Log($"Watchdog! {FileJanitor.LockFileWriteTime(_lastUsedPath)} {_lockNextUpdate} {DateTime.UtcNow} ");
			if (null != _lockFile && (elapsed > _lockUpdatePeriodMs || force))
			{
				_lockLastUpdateMs = now;
				//Stopwatch w = Stopwatch.StartNew();

				_lockFile.Seek(0, SeekOrigin.Begin);
				_lockFile.WriteByte(0);
				_lockFile.Flush(true);
				Log("LockFile updated");
				//Log($"Lock file updated. Update took: {w.ElapsedMilliseconds} ms");
				//? _lockFile.SetLength(0);
			}
		}


		private void VerifyOrDeployResources(string deploymentPath, Opt options)
		{
			DisposeResourceFiles();
			// Check, if we can load the existing resource files
			try
			{
				Dbg("last.allFoundImmediately", false);
				if (VerifyExistingResourceFiles(deploymentPath, options))
				{
					Log("All files already deployed");
					Dbg("last.allFoundImmediately", true);
					return;
				}
			}
			catch
			{
				Log("1st Verify call threw");
				throw;
			}

			Dbg("last.lockWaitSince", DateTime.Now);
			Dbg("last.lockedAt", null);
			Dbg("last.lockWaitTimeoutAt", null);
			Dbg("last.lockFileAgeMs", null);

			int startTime = Environment.TickCount, startTime0 = startTime;
			int retries = 3;
			int timeout = _retryTimeoutMs;
			while (null == (LockFile = FileJanitor.TryCreateLockFile(deploymentPath)))
			{
				Int32 elapsed = Environment.TickCount - startTime;
				// Yes, sleep at least once regardless of how much time remaining and re-check
				RandomSleep(timeout - elapsed);
				if (elapsed < timeout || --retries >= 0)
					continue;

				DateTime now = DateTime.UtcNow;
				double lockFileAge = (now - FileJanitor.LockFileWriteTime(deploymentPath)).TotalMilliseconds;
				// If lockfile is updated between retryTimeout in the past and retryTimeout * 10 in the future(!!), extend timer
				if (lockFileAge < timeout && lockFileAge > -10 * timeout)
				{
					startTime = Environment.TickCount;
					retries = 3;
					Log("Lock timer extended");
					continue;
				}

				int elapsedTotal = Environment.TickCount - startTime0;
				Log(ERR, $"Lock timer expired at: {Dt2Str(now)}, elapsed: {elapsedTotal} ms, lock age: {lockFileAge} ms");
				DbgLast("lockWaitTimeoutAt", now);
				DbgLast("lockFileAgeMs", lockFileAge);
				throw new IOException(
					$"Unable to grab Lock file (timeout: {timeout} ms, elapsed: {elapsedTotal} ms, lock age: {lockFileAge} ms)");
			}

			var dtNow = DateTime.Now;
			Dbg("last.lockedAt", dtNow);
			if (LogLevelLeast(DBG))
				Log($"Lock taken at: {Dt2Str(dtNow)}");

			try
			{
				try
				{
					// Check again after possible lock contention
					DbgLast("verifyOkAfterLock", false);
					if (VerifyExistingResourceFiles(deploymentPath, options))
					{
						DbgLast("verifyOkAfterLock", true);
						Log("Verified files after lock");
						return;
					}
				}
				catch
				{
					Log("2nd Verify call threw");
					DbgLast("2ndVerifyThrew", true);
					throw;
				}

				Log($"Deploying to: {deploymentPath}");
				LockFileWatchdogInit();

				try
				{
					DbgLast("deployAttempted", true);
					DeployResourcesInternal(deploymentPath);
				}
				catch
				{
					DbgLast("deployThrew", true);
					Log("Deployment threw");
					throw;
				}

				// Update watchdog one last time
				LockFileWatchdogUpdate();
			}
			catch
			{
				Log("Verify/Deploy throw/rethrow");
				throw;
			}

			// NOTE: LockFile may still exist and will be released later byt the caller
			// finally{} clause that releases the lock is removed from here
		}


		private void DeployResourcesInternal(string deploymentPath)
		{
			byte[] inputData = this.InputBuffer;
			byte[] decompressedData = _outputBuffer;

			var fileList = _resources.ToList();
			fileList.Sort(
				(x, y) =>
				/* non-null(existing files) before non-null */
				null != x.File && null == y.File ? -1 :
				null == x.File && null != y.File ? 1 :
				/* otherwise, descending order by size */
				y.Length.CompareTo(x.Length)
			);

			foreach (var resource in fileList)
			{
				// If partial reuse is allowed and we already locked some files for read, do not deploy them
				if (null != resource.File)
					continue;

				string filePath = resource.FullPath(deploymentPath);
				byte[] outputData = inputData;

				Log($"Reading {filePath}");
				using (var resourceStream = _assembly.GetManifestResourceStream(resource.ResourcePath))
					ReadResourceFile(resourceStream, inputData, resource.Length);

				long outputLength = resource.Length;
				if (resource.IsZstd)
				{
					outputLength = (long)ZStdDecompress.GetDecompressedSize(inputData);
					if (null == decompressedData || outputLength > decompressedData.Length)
						decompressedData = _outputBuffer = new byte[outputLength];

					outputData = decompressedData;
					ZStdDecompress.Decompress(decompressedData, inputData);
				}

				LockFileWatchdogUpdate();
				// Patch library internal name if it is changed during decompression.
				// This feature will be cleaned/improved in the future
				if (null != _libraryNameSuffix)
					RenameLibraryIfNeeded(outputData, filePath, "@@@@", _libraryNameSuffix);

				Log($"Writing {filePath}");
				using (var fs = new FileStream(filePath, FileMode.Create, FileAccess.ReadWrite, FileShare.None))
				{
					WriteResourceFile(fs, outputData, Convert.ToInt32(outputLength));
					Log($"Done writing {filePath}, closing");
					Dbg("last.lastWrittenFile", filePath);
				}

				Log($"After writing {filePath}, taking read lock");
				resource.ReadLock(filePath);
			}
		}

		private void ReadResourceFile(Stream fs, byte[] buffer, int length)
		{
			int offset = 0;
			while (length > 0)
			{
				int numRead = fs.Read(buffer, offset, Math.Min(ReadWriteBlockSize, length));
				offset += numRead;
				length -= numRead;
				if (numRead <= 0)
					throw new IOException("Prematurely reached end-of-file");
				LockFileWatchdogUpdate();
			}
		}


		private void WriteResourceFile(FileStream fs, byte[] buffer, int length)
		{
			int offset = 0;

			while (length > 0)
			{
				int n;
				fs.Write(buffer, offset, n = Math.Min(ReadWriteBlockSize, length));
				offset += n;
				if ((length -= n) > 0)
					fs.Flush();	// Big files will be periodically flushed so the concurrent processes can react

				LockFileWatchdogUpdate();
			}
		}

		// Unused
		private void FlushResourceFiles()
		{
			foreach (var resource in _resources)
				resource.File?.Flush();
		}

		private void DisposeResourceFiles()
		{
			foreach (var resource in _resources)
				resource.File = null;
		}

		// returns false is some of the files are not found
		// when returning false, when ReusePartiallyDeployed is set, SOME of the files may be opened/read-locked
		// returns true is ALL needed files are found AND read-locked
		// returns true is ReusePartiallyDeployed is set and SOME needed files are found AND read-locked 
		private bool VerifyExistingResourceFiles(string deploymentPath, Opt options)
		{
			// Verify automatically fails if overwrite mode is forced
			if (options.HasFlag(Opt.AlwaysOverwrite))
			{
				Dbg("last.verifyExisting", "OverwriteAnyway");
				return false;
			}

			// Make sure all resource files are closed
			if (!options.HasFlag(Opt.ReusePartiallyDeployed))
				DisposeResourceFiles();

			int timeout = _retryTimeoutMs;
			int numExpected = _resources.Count;
			do
			{
				int numFound = 0, numOpened = 0;
				foreach (var resource in _resources)
				{
					string filePath = resource.FullPath(deploymentPath);

					if (File.Exists(filePath))
					{
						++numFound;
						DbgLast("filesExisted", numFound);
						if (null == resource.File)
						{
							DbgLast("readLockTries", numFound);
							try
							{
								if (LogLevelLeast(DBG))
									Log($"Found existing, taking read lock: {filePath}");

								resource.ReadLock(filePath);
							}
							catch (IOException)
							{
								// On simple IOException (Also returned due to failed locks), but no lockfile, we will wait until timeout
								continue;
							}

							if (0 != (options & (Opt.VerifyContent | Opt.VerifyLength)))
							{
								long fileLength = new FileInfo(filePath).Length;
								// TODO: Must cache file size and hash for verification. Loading from zstd every time is wrong
								//if (options.HasFlag(Opt.VerifyLength))
								//{
								//	if (fileLength == (resource.IsZstd ? (long)ZStdDecompress.GetDecompressedSize(inputData) : length))
								//		continue;
								//}
							}
						}

						++numOpened;
					}
				}

				// Nothing found? Fail immediately
				if (0 == numFound)
				{
					Dbg("last.verifyExisting", "Nothing");
					break;
				}

				// All found? Return success
				if (numOpened == numExpected)
				{
					Dbg("last.verifyExisting", "All");
					return true;
				}

				// Able to open some of the files
				if (numOpened == numFound)
				{
					Dbg("last.verifyExisting", "Some");
					break;
				}

				// If there is a lock file, fail
				if (FileJanitor.LockFileExists(deploymentPath))
				{
					Dbg("last.verifyExisting", "Locked");
					break;
				}

				// Ok, we can't open _some_ of the files we found and there is no lock file. Probably being written, but not by this class.
				// Wait and retry until timeout
				timeout -= RandomSleep(timeout);
			} while (timeout > 0);

			if (!options.HasFlag(Opt.ReusePartiallyDeployed))
				DisposeResourceFiles();

			return false;
		}


		private void ResourceAdded(Resource r)
		{
			long length = r.Length;
			_totalResourceLength += length;
			if (_maxResourceLength < length)
				_maxResourceLength = length;

			if (r.IsDll)
				++_dlCount;

			if (!IsAscii(r.Filename))
				Dbg("dep.hasNonAsciiFilename", true);
		}


		private void ListResources()
		{
			_maxResourceLength = -1;
			_totalResourceLength = 0;
			_dlCount = 0;
			_resources = new List<Resource>();
			int orderIndex = 0;
			int pathLength = _resourcePrefix.LastIndexOf('.') + 1;
			foreach (string x in _assembly.GetManifestResourceNames())
				if (null == _resourceSuffix
					? x.Equals(_resourcePrefix)
					: x.StartsWith(_resourcePrefix) && x.EndsWith(_resourceSuffix))
					_resources.Add(new Resource(x, pathLength, orderIndex++, this));

			// No resources to deploy?
			if (_resources.Count < 1)
			{
				_resources = null;
				throw new ArgumentException(
					$"No resources found for: {_resourcePathTemplate} -> {_resourcePrefix}*{_resourceSuffix}");
			}

			_resources.Sort();
			if (LogLevelLeast(DBG))
				foreach (var r in _resources)
					Log($"{r.Order} : {r.Filename}");
		}


		private void LoadDynamicLibraries(string deploymentPath)
		{
			// On Linux out deployment path is not searched to resolve library interdependencies,
			// we solve this by using lazy binding though this is not a great solution
			bool useLazyBinding = _dlCount > 1;
			int numLoaded = 0;
			bool loadedLeastOne;
			DlException exception = null;
			// Remembers "Current directory", to be restored on exit. Part of the workaround for Mac OSX.
			string oldCwd = null;

			// This method works as a workaround for Mac OSX at least
			if (OS.IsOsx)
			{
				oldCwd = Directory.GetCurrentDirectory();
				Directory.SetCurrentDirectory(deploymentPath);
			}

			try
			{
				do
				{
					loadedLeastOne = false;
					foreach (var resource in _resources)
						if (resource.IsDll && IntPtr.Zero == resource.DlHandle)
						{
							// Workaround, load from the current dir on OSX
							var path = OS.IsOsx ? resource.Filename : resource.FullPath(deploymentPath);
							Dbg("last.dllExisted", File.Exists(path));
							Dbg("last.dllHadLock", null != resource.File);
							Dbg("last.dllsLoaded", numLoaded);

							if (LogLevelLeast(DBG))
								Log($"Loading DLL#{numLoaded + 1}: {path} , exists: {File.Exists(path)}, hasLockFile: {null != resource.File}");

							exception = null;
							if (IntPtr.Zero == (resource.DlHandle = OS.LoadNativeLibrary(path, useLazyBinding)))
							{
								string errorText = OS.LastDlErrorText();
								if (LogLevelLeast(DBG))
									Log($"LoadLibrary Exception : {errorText}");
								exception = new DlException($"{path} : {errorText}");
							}
							else
							{
								Log("ook");
								++numLoaded;
								loadedLeastOne = true;
								Dbg("last.dllsLoaded", numLoaded);
							}
						}
				} while (loadedLeastOne);
			}
			finally
			{
				if (null != oldCwd)
					Directory.SetCurrentDirectory(oldCwd);
			}

			if (null != exception)
				throw exception;
		}


		private void KeepDllFileHandles()
		{
			// On Linux platforms higher than
			foreach (var resource in _resources)
				if (resource.IsDll && null != resource.File)
					lock (LockedDlls)
					{
						LockedDlls.Add(resource.MoveFileHandle());
					}
		}


		private void UnloadDynamicLibraries()
		{
			foreach (var resource in _resources)
				if (IntPtr.Zero != resource.DlHandle)
				{
					OS.UnloadNativeLibrary(resource.DlHandle);
					resource.DlHandle = IntPtr.Zero;
				}
		}


		private void LoadAt(string deploymentPath)
		{
			if (null == _resources)
				throw new Exception("No resources to deploy");

			Opt options = _deploymentOptions;

			if (!Path.IsPathRooted(deploymentPath))
				throw new Exception($"Deployment path can't be relative: {deploymentPath}");

			if (!Directory.Exists(deploymentPath))
				Directory.CreateDirectory(deploymentPath);

			if (_retryTimeoutMs < 0)
				_retryTimeoutMs = (int)(_totalResourceLength / 4000 + 4000); // 4 MB/s + 4 sec

			// Update period fixed to be frequent enough to not cause _any_ concurrent processes to timeout
			// regardless of how big _their_ files are
			// It is guaranteed to be <= _retryTimeoutMs / 2
			_lockUpdatePeriodMs = 2000;

			Dbg("dep.retryTimeoutMs", _retryTimeoutMs);
			Dbg("dep.lockUpdatePeriodMs", _lockUpdatePeriodMs);

			if (!OS.IsWindows)
				options |= Opt.KeepDllsLocked;

			Log($"RetryTimeout:{_retryTimeoutMs}, LockUpdatePeriod: {_lockUpdatePeriodMs}"
				+ (options.HasFlag(Opt.KeepDllsLocked) ? ", KeepDllsLocked=1" : ""));

			Dbg("dep.alwaysOverwrite", options.HasFlag(Opt.AlwaysOverwrite));
			Dbg("dep.reusePartiallyDeployed", options.HasFlag(Opt.ReusePartiallyDeployed));
			Dbg("dep.keepDllsLocked", options.HasFlag(Opt.KeepDllsLocked));
			try
			{
				VerifyOrDeployResources(deploymentPath, options);
				if (_shouldLoadDlls)
				{
					Log("loading libs..");
					DbgLast("triedLoadingLibs", true);
					LoadDynamicLibraries(deploymentPath);
					if (options.HasFlag(Opt.KeepDllsLocked))
						KeepDllFileHandles();
				}
			}
			catch
			{
				if (_shouldLoadDlls)
				{
					// If some libs were already loaded before throwing, unload. All libs must be only loaded from a single deployment path.
					Log("UNloading libs..");
					UnloadDynamicLibraries();
					// If failed to load libs, always drop file locks
					DisposeResourceFiles();
				}

				LockFile = null;
				throw;
			}
			finally
			{
				// Ensure all resource files are closed
				Log("Dropping resource file locks..");
				DisposeResourceFiles();
				// If lock file existed, update the last time before deletion
				if (null != _lockFile)
					LockFileWatchdogUpdate(true);

				LockFile = null;
			}
		}


		private bool IsIgnoredException(Exception e)
		{
			return e is IOException || e is UnauthorizedAccessException || e is DlException;
		}

#if OSX_FIX_ATTEMPT_1_
		private void AddOsxDlPath(string varName, string path)
		{
			// Set environment path for OSX and _unload_ the libs! 
			var value = Environment.GetEnvironmentVariable(varName);
			if (null == value || !value.Contains(path))
			{
				Environment.SetEnvironmentVariable(varName,
					value = (null != value ? path + ';' + value : path));
			}

			Log(ERR, $"{varName}={value}");
		}
#endif

		private bool TryLoadAt(string deploymentPath)
		{
			_lastUsedPath = deploymentPath;
			DbgClear("last.");
			Dbg("last.path", deploymentPath);
			if (!IsAscii(deploymentPath))
				Dbg("last.pathNonAscii", true);
			try
			{
				LoadAt(deploymentPath);
				_lastSuccessfulPath = _lastUsedPath;
#if OSX_FIX_ATTEMPT_1_
				if (OS.IsOsx)
				{
					// Set environment path for OSX and _unload_ the libs!
					AddOsxDlPath("LD_LIBRARY_PATH", deploymentPath);
					AddOsxDlPath("DYLD_LIBRARY_PATH", deploymentPath);
					AddOsxDlPath("DYLD_FALLBACK_LIBRARY_PATH", deploymentPath);
				}
#endif

				return true;
			}
			catch (Exception e)
			{
				if (!IsIgnoredException(e))
					throw;

				LastDeploymentException = e;
				Log($"Failed to deploy to: {deploymentPath}");
				return false;
			}
		}


		private void LoadInternal()
		{
			if (null == _resourcePrefix)
				throw new ArgumentException("Resource path is not set, use From(resourcePathTemplate) to set");

			if (null == _deploymentPathTemplate)
				throw new ArgumentException("Deployment path is not set, use To(deploymentPathTemplate) to set");

			if (_deploymentOptions.HasFlag(Opt.AlwaysOverwrite | Opt.ReusePartiallyDeployed))
				throw new ArgumentException("AlwaysOverwrite=true is not compatible with ReusePartiallyDeployed=true");

			// Fill debug info structure
			Dbg("cfg.", "Config");
			Dbg("res.", "Resource");
			Dbg("pl.", "Platform");
			Dbg("dep.", "Deployment");
			Dbg("last.", "LastDeployment");

			Dbg("pl.OS", OS.Name);
			Dbg("pl.Is64Bit", OS.Is64);
			Dbg("res.AssemblyVersion", OS.AssemblyVersion);

#if !NETSTANDARD_BELOW_2_0
			Dbg("pl.RuntimeDir", RuntimeEnvironment.GetRuntimeDirectory());
			Dbg("pl.ClrVersion", Environment.Version);
#endif

			Dbg("cfg.resourceTemplate", _resourcePathTemplate);
			Dbg("cfg.deploymentTemplate", _deploymentPathTemplate);

			Dbg("cfg.addDllSuffix", _libraryNameSuffix);
			Dbg("cfg.addRandomFallbackSubDirectory", _addRandomFallbackSubDirectory);
			Dbg("cfg.retryTimeoutMs", _retryTimeoutMs);
			Dbg("cfg.lockUpdatePeriodMs", _lockUpdatePeriodMs);

			if (null != LockedDlls)
			{
				Dbg("lockedDlls.", "lockedDlls");
				Dbg("lockedDlls.countBefore", LockedDlls.Count);
			}


			string path = ApplyPathTemplate(_deploymentPathTemplate, ResourceAssembly);
			var paths = new List<string>();
			// If user did not specify his preferred deployment root path, prepare our own
			if (!Path.IsPathRooted(path))
			{
#if !NETSTANDARD_BELOW_2_0
				// GetFolderPath is not supported everywere, therefore it is optional
				string[] rootPaths = {
					// CommonApplicationData typically unavailable on Linux and on some Windows systems
					Environment.GetFolderPath(Environment.SpecialFolder.CommonApplicationData),
					Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData)
				};

				foreach (var rootPath in rootPaths)
					if (!string.IsNullOrEmpty(rootPath))
						paths.Add(Path.Combine(rootPath, path));
#endif
				// Temp dir and random subfolders in the temp dir are always enabled
				var fallbackPath = Path.Combine(Path.GetTempPath(), path);
				var fallbackPath2 = Path.Combine(fallbackPath, NextRandomDirString());
				paths.Add(fallbackPath);
				paths.Add(fallbackPath2);
				FileJanitor.AddCleanupPath(fallbackPath, false, RandomDirRegEx);
			}
			else
			{
				paths.Add(path);
				if (_addRandomFallbackSubDirectory)
				{
					paths.Add(Path.Combine(path, NextRandomDirString()));
					FileJanitor.AddCleanupPath(path, false, RandomDirRegEx);
				}
			}

#if NETSTANDARD_BELOW_2_0
// There will be no on-exit cleanup callback for these version, try to clean immediately
			FileJanitor.TryCleanup();
			Dbg("dep.cleanupAt", "BeforeDeploy");
#else
			FileJanitor.RegisterForCleanupOnExit();
			Dbg("dep.cleanupAt", "Exit");
#endif

			try
			{
				if (!IsAscii(_resourcePathTemplate))
					Dbg("res.templateIsNonAscii", true);

				if (null == _resources)
					ListResources();

				Dbg("res.count", _resources.Count);
				Dbg("res.maxSrcLength", _maxResourceLength);
				Dbg("res.dllCount", _dlCount);
				Dbg("res.count", _resources.Count);

				if (LogLevelLeast(DBG))
				{
					Log("Deployment paths:");
					foreach (string p in paths)
						Log(p);
				}

				Dbg("dep.paths", paths.ToArray());
				foreach (string p in paths)
				{
					if (TryLoadAt(p))
						return;
				}
			}
			catch (Exception e)
			{
				LastDeploymentException = e;
			}

			// Failure!
			if (null != LockedDlls)
				Dbg("lockedDlls.countAfter", LockedDlls.Count);

			Dbg("last.", "LastDeployment");
			throw new Exception(
				$"ERROR: Failed to deploy/load resources at path: \"{_lastUsedPath}\" \nConfiguration: \n{_diag}",
				LastDeploymentException);
		}

		private static void RenameLibraryIfNeeded(byte[] decompressedData, string filePath, string from, string to)
		{
			if (!OS.IsWindows && to.Length != 0 && to.Length <= from.Length)
			{
				// If renaming Linux/OSX lib, try to also patch internal name before saving.
				// Extra chars are nececcary to reserve space(from.length >= to.length). Temporary kludge that seems to work well.
				var suffix = OS.DllExt;
				if (filePath.EndsWith(OS.DllExt))
					Replace(decompressedData, from + suffix, to + suffix);
			}
		}

		// Replace substring with 0-padding
		private static void Replace(byte[] data, string src, string dst)
		{
#if HAS_CONTRACTS
			Contract.Assert(dst.Length <= src.Length);
			Contract.EndContractBlock();
#endif

			int l1 = src.Length;
			int l2 = dst.Length;
			var srcBytes = System.Text.Encoding.ASCII.GetBytes(src);
			for (int i = 0, n = data.Length - l1; i < n; ++i)
			{
				for (int j = 0; data[i + j] == srcBytes[j]; ++j)
				{
					if (j == l1 - 1)
					{
						for (int k = 0; k < l1; ++k)
							data[i + k] = k < l2 ? (Byte)dst[k] : (Byte)0;

						return;
					}
				}
			}
		}

		//internal ResourceLoader RegisterForCleanup(string cleanedRootPath, bool withSubdirs)
		//{
		//	FileJanitor.RegisterForCleanup(cleanedRootPath, withSubdirs);
		//	return this;
		//}

		/**
		 * Public interface implementation
		 */

		private ResourceLoader FromInternal(string resourcePathTemplate, Assembly assembly = null)
		{
			if (null == resourcePathTemplate)
				throw new ArgumentNullException(nameof(resourcePathTemplate));

			if (null != _resourcePrefix)
				throw new ArgumentException("Resource path is already specified!");

			if (null != _assembly)
			{
				if (null != assembly && assembly != _assembly)
					throw new ArgumentException($"Assembly field already set: {_assembly}");
			}
			else
			{
				_assembly = assembly ?? OS.CurrentAssembly;
			}

			_resourcePathTemplate = resourcePathTemplate;
			string pattern = ApplyBasicTemplate(resourcePathTemplate, _assembly);
			string[] parts = pattern.Split('*');
			_resourcePrefix = _resourceSuffix = null;
			_resourceSuffix = parts.Length > 1 ? parts[1] : null;

			// TODO: Improve handling of '*', currently we allow directly specified filename again
			//if (parts.Length < 2)
			//throw new ArgumentException("Resource path template must contain * character. Example: \"MyCompany.Resources.$(OS).x$(ARCH).*\"");

			if (parts.Length > 2)
				throw new ArgumentException("Resource path template must contain exactly one * character!");

			_resourcePrefix = parts[0];
			return this;
		}

		/// <summary>
		/// Set resource path template. Resources matching the template will be deployed as files.
		/// The template must contains exactly 1 asterisk character, denoting variable part of the resource name that will become the actual filename.
		/// More advanced search masks or Regular Expressions are not supported.
		/// Underscore character in the filename will be replaced with dot character.
		/// Resources, whose names were ending with '_zstd' will be decompressed by ZStandard with '_zstd' suffix removed
		/// The following variables will be substituted:
		/// <list>
		/// <item>$(OS) => 'Windows' | 'Linux' | 'OSX' - name of the current OS platform</item>
		/// <item>$(VERSION) => current assembly name in the form of 'X.X.X.X'</item>
		/// <item>$(ARCH) => '32' | '64' - pointer size on the current architecture</item>
		/// <item>$(DLLEXT) => 'dll' | 'so' | 'dylib' - dynamic library file extension for the current OS platform</item>
		/// </list>
		/// </summary>
		/// 
		/// <param name="resourcePathTemplate"></param>
		/// <returns>Instance of partially initialized ResourceLoader, call .To() to set deployment path</returns>
		public static IResourceLoaderInstanceFrom From(string resourcePathTemplate)
		{
			return NewInstance().FromInternal(resourcePathTemplate);
		}

		public static IResourceLoaderInstanceFrom From(Assembly resourceAssembly, string resourcePathTemplate)
		{
			return NewInstance().FromInternal(resourcePathTemplate, resourceAssembly);
		}

		/// <summary>
		/// Set resource path template. Resources matching the template will be deployed as files.
		/// The template must contains exactly 1 asterisk character, denoting variable part of the resource name.
		/// More advanced search masks or Regular Expressions are not supported.
		/// Underscore character in the filename will be replaced with dot character.
		/// Resources, whose names were ending with '_zstd' will be decompressed by ZStandard with '_zstd' suffix removed
		/// The following variables will be substituted:
		/// <list>
		/// <item>$(OS) => 'Windows' | 'Linux' | 'OSX' - name of the current OS platform</item>
		/// <item>$(VERSION) => current assembly name in the form of 'X.X.X.X'</item>
		/// <item>$(ARCH) => '32' | '64' - pointer size on the current architecture</item>
		/// <item>$(DLLEXT) => 'dll' | 'so' | 'dylib' - dynamic library file extension for the current OS platform</item>
		/// </list>
		/// </summary>
		/// 
		/// <param name="resourcePathTemplate"></param>
		/// <returns>Instance of initialized ResourceLoader, user can still specify optional parameters before calling .Load()</returns>
		IResourceLoaderInstance IResourceLoaderInstanceTo.From(string resourcePathTemplate)
		{
			return FromInternal(resourcePathTemplate);
		}

		IResourceLoaderInstance IResourceLoaderInstanceTo.From(Assembly resourceAssembly, string resourcePathTemplate)
		{
			return FromInternal(resourcePathTemplate, resourceAssembly);
		}

		private ResourceLoader ToInternal(string deploymentRelativePathTemplate)
		{
			if (null == deploymentRelativePathTemplate)
				throw new ArgumentNullException(nameof(deploymentRelativePathTemplate));

			// Create system-dependent path and apply template parameters
			_deploymentPathTemplate = deploymentRelativePathTemplate.Replace('/', Path.DirectorySeparatorChar);
			return this;
		}

		/// <summary>
		/// Set deployment path template. Resource files will be deployed at the path generated from this template.
		/// If the path, after expansion, is absolute, it is used as-is and exception is thrown on deployment failure.
		/// If the path is relative, several deployment root paths may be tried before reporting failure.
		/// The following variables will be substituted:
		/// <list>
		/// <item>$(OS) => 'Windows' | 'Linux' | 'OSX' - name of the current OS platform</item>
		/// <item>$(VERSION) => current assembly name in the form of 'X.X.X.X'</item>
		/// <item>$(ARCH) => '32' | '64' - pointer size on the current architecture</item>
		/// <item>$(DLLEXT) => 'dll' | 'so' | 'dylib' - dynamic library file extension for the current OS platform</item>
		/// <item>$(TEMP) => Temporary directory for the current user</item>
		/// <item>$(RANDOM) => random 8-digit hexadecimal string</item>
		/// <item>$(COMMONAPPDATA) => shared application data directory, not available on older .NET platforms</item>
		/// <item>$(LOCALAPPDATA) => local current user's application data, not available on older .NET platforms</item>
		/// </list>
		/// </summary>
		/// <param name="deploymentRelativePathTemplate"></param>
		/// <returns>Instance of partially initialized ResourceLoader, call .From() to set resource search mask</returns>
		public static IResourceLoaderInstanceTo To(string deploymentRelativePathTemplate)
		{
			return NewInstance().ToInternal(deploymentRelativePathTemplate);
		}

		/// <summary>
		/// Set deployment path template. Resource files will be deployed at the path generated from this template.
		/// If the path, after expansion, is absolute, it is used as-is and exception is thrown on deployment failure.
		/// If the path is relative, several deployment root paths may be tried before reporting failure.
		/// The following variables will be substituted:
		/// <list>
		/// <item>$(OS) => 'Windows' | 'Linux' | 'OSX' - name of the current OS platform</item>
		/// <item>$(VERSION) => current assembly name in the form of 'X.X.X.X'</item>
		/// <item>$(ARCH) => '32' | '64' - pointer size on the current architecture</item>
		/// <item>$(DLLEXT) => 'dll' | 'so' | 'dylib' - dynamic library file extension for the current OS platform</item>
		/// <item>$(TEMP) => Temporary directory for the current user</item>
		/// <item>$(RANDOM) => random 8-digit hexadecimal string</item>
		/// <item>$(COMMONAPPDATA) => shared application data directory, not available on older .NET platforms</item>
		/// <item>$(LOCALAPPDATA) => local current user's application data, not available on older .NET platforms</item>
		/// </list>
		/// </summary>
		/// <param name="deploymentRelativePathTemplate"></param>
		/// <returns>Instance of initialized ResourceLoader, user can still specify optional parameters before calling .Load()</returns>
		IResourceLoaderInstance IResourceLoaderInstanceFrom.To(string deploymentRelativePathTemplate)
		{
			return ToInternal(deploymentRelativePathTemplate);
		}

		IResourceLoaderInstance IResourceLoaderInstance.AlwaysOverwrite(bool alwaysOverwrite)
		{
			_deploymentOptions = (_deploymentOptions & ~Opt.AlwaysOverwrite)
								 | (alwaysOverwrite ? Opt.AlwaysOverwrite : 0);
			return this;
		}

		/// <summary>
		/// <para/>If an absolute deployment path is given, and it we failed to deploy at that location,
		/// try to use an alternative deployment path generated by concatenating a random subdirectory name with the specified path
		/// </summary>
		/// <param name="enable">If true, use a subdirectory with random name as fallback
		/// <para/>false by default</param>
		/// 
		/// <returns>Instance of initialized ResourceLoader, user can still specify optional parameters before calling .Load()</returns>
		IResourceLoaderInstance IResourceLoaderInstance.TryRandomFallbackSubDirectory(bool enable)
		{
			_addRandomFallbackSubDirectory = enable;
			return this;
		}

		/// <summary>
		/// <para/>By default, we only reuse the existing files if all were already found in the target directory and try to create or overwrite all the files otherwise
		/// <para/>If some but not all files are found, enable reuse of existing files without trying to overwrite them while only deploying the missing ones.
		/// <para/>This is a dangerous behavior which is disabled by default. This option does not imply file contents verification.
		/// </summary>
		/// <param name="reuseEnabled">Enable reuse of partially deployed fileset</param>
		/// <returns></returns>
		IResourceLoaderInstance IResourceLoaderInstance.ReusePartiallyDeployed(bool reuseEnabled)
		{
			_deploymentOptions = (_deploymentOptions & ~Opt.ReusePartiallyDeployed)
								 | (reuseEnabled ? Opt.ReusePartiallyDeployed : 0);
			return this;
		}

		IResourceLoaderInstance IResourceLoaderInstance.ShouldLoadDlls(bool shouldLoadDlls)
		{
			_shouldLoadDlls = shouldLoadDlls;
			return this;
		}

		IResourceLoaderInstance IResourceLoaderInstance.AddDllSuffix(string libraryNameSuffix)
		{
			if (string.IsNullOrEmpty(libraryNameSuffix))
				throw new ArgumentException("libraryNameSuffix should not be empty", nameof(libraryNameSuffix));

			_libraryNameSuffix = libraryNameSuffix;
			return this;
		}

		IResourceLoaderInstance IResourceLoaderInstance.RetryTimeout(int millis)
		{
			_retryTimeoutMs = millis;
			return this;
		}

		IResourceLoaderDone IResourceLoaderInstance.Load()
		{
			LoadInternal();
			return this;
		}

		IResourceLoaderDone IResourceLoaderDone.UnloadDlls()
		{
			if (null == _resources)
				throw new InvalidOperationException("No resources were loaded");

			UnloadDynamicLibraries();
			return this;
		}

		internal string Diagnostics => _diag?.ToString();

		string IResourceLoaderBase.ActualResourcePath =>
			null != _resourcePrefix ? $"{_resourcePrefix}*{_resourceSuffix}" : null;

		string IResourceLoaderBase.ActualDeploymentPath => _lastSuccessfulPath ?? _lastUsedPath;

		public Assembly ResourceAssembly => _assembly;

		public static void CleanDir(string directoryTemplate)
		{
			FileJanitor.TryCleanup(ApplyPathTemplate(directoryTemplate));
		}

		public static void CleanSubdirs(string directoryTemplate)
		{
			FileJanitor.TryCleanup(ApplyPathTemplate(directoryTemplate), false, RandomDirRegEx);
		}

#if !NETSTANDARD_BELOW_2_0
		public static void CleanDirOnExit(string directoryTemplate)
		{
			FileJanitor.RegisterForCleanupOnExit();
			FileJanitor.AddCleanupPath(ApplyPathTemplate(directoryTemplate));
		}

		public static void CleanSubdirsOnExit(string directoryTemplate)
		{
			FileJanitor.RegisterForCleanupOnExit();
			FileJanitor.AddCleanupPath(ApplyPathTemplate(directoryTemplate), false, RandomDirRegEx);
		}
#endif
		/// <summary>
		/// Debug option
		/// Add the specified StreamWriter as the destination for logging
		/// Does not change the logging level
		/// If at least one lodding destination is added, logging to console is turned off
		/// use null argument to re-add console logging
		/// </summary>
		/// <param name="logWriter">logging destination. pass null to add console output</param>
		internal static void AddLogSink(StreamWriter logWriter)
		{
			Logger.AddSink(logWriter);
		}
	}

	internal class DlException : Exception
	{
		public DlException(string message) : base(message)
		{
		}
	}
}
