package rtmath.utilities;

/**
 * Configuration Builder interface for {@code ResourceLoader}.
 * Lets you specify optional configuration options.
 * Call load() when finished with configuration.
 */
public interface ResourceLoaderInstance {
    interface ResourceLoaderBase {
        /**
         * Get the resource path.
         * @return Resource path after template var substitution.
         */
        String getActualResourcePath();

        /**
         * Get deployment path (after .load()).
         * @return Actual path used for deployment. Only available after calling load(). May be null.
         */
        String getActualDeploymentPath();
    }

    /**
     * Always overwrite existing files, false by default.
     * <p>Do not check for the existing files, always overwrite.
     * <p>Incompatible with {@code reusePartiallyDeployed}.
     * <p>Note that this option demands that we don't share our deployed files with another instance
     * and try other deployment paths if there is a conflict.
     * Therefore, {@code tryRandomFallbackSubDirectory} probably should probably be set to true.
     *
     * @param alwaysOverwrite should always overwrite existing files and fail if unable to. False by default.
     * @return This {@code ResourceLoaderInstance}
     */
    ResourceLoaderInstance alwaysOverwrite(boolean alwaysOverwrite);

    /**
     * Always reuse already existing files, false by default.
     * <p>By default, we only reuse the existing files if all were found in the target directory and try to create
     * or overwrite all the files otherwise.
     * <p>If some but not all files are found, enable reuse of existing files without trying to overwrite them
     * while only deploying the missing ones.
     * <p>This is a dangerous behavior which is disabled by default.
     * This option does not imply file contents or length verification.
     * Incompatible with {@code alwaysOverwrite}.
     *
     * @param reuseEnabled Enable reuse of partially deployed fileset. False by default.
     * @return This {@code ResourceLoaderInstance}
     */
    ResourceLoaderInstance reusePartiallyDeployed(boolean reuseEnabled);

    /**
     * Load deployed Dynamic Libraries, true by default.
     * Set, if the ResourceLoader should load dynamic libraries found among resource files.
     *
     * @param shouldLoadDlls Load dynamic libraries. True by default.
     * @return This {@code ResourceLoaderInstance}
     */
    ResourceLoaderInstance shouldLoadDlls(boolean shouldLoadDlls);

    /**
     * Try random fallback subdirectory if all else fails, false by default.
     * <p>If an absolute deployment path is given, and it we failed to deploy at that location,
     * try to use an alternative deployment path generated by concatenating a random subdirectory name
     * with the specified path.
     *
     * @param enable If true, use a subdirectory with random name as the last fallback directory.
     *               False by default.
     * @return This {@code ResourceLoaderInstance}
     */
    ResourceLoaderInstance tryRandomFallbackSubDirectory(boolean enable);

    /**
     * Add the specified suffix to the end of dynamic library filename(s), none by default.
     * <p>On Linux(Osx?), library contains its own filename inside the file and it will be patched as well,
     * replacing a sequence of characters "@@@@.DlExt" with "suffix.DlExt".
     * <p>The library should be compiled in a way that leaves enough space for the suffix inside the file
     * (created with a longer filename ending with @@@@.so and then renamed)
     * <p>Used to implement a particular variant of resource versioning.
     * <p>(Don't use this if you have not compiled your library in a specific way.)
     * <p>
     * @param libraryNameSuffix DL filename suffix. None by default.
     * @return This {@code ResourceLoaderInstance}
     */
    ResourceLoaderInstance addDllSuffix(String libraryNameSuffix);

    /**
     * Set retry timeout, automatic (-1) by default.
     * <p>Specify retry timeout in milliseconds. This is the _minimum_ time to wait in the case of resource
     * deployment contention for each possible deployment path. Wait time can be still extended indefinitely if another
     * instance of the ResourceLoader is writing to some files in the directory
     * (regularly updates lockfile.$$$ write time).
     *
     * <p>By default, timeout is calculated from the _compressed_ size of the deployed data.
     * @param millis Minimum deployment timeout.
     * @return This {@code ResourceLoaderInstance}
     */
    ResourceLoaderInstance retryTimeout(int millis);

    /**
     * Load the resource set.
     * Call this method after finishing with the configuration.
     * @return This instance as {@code ResourceLoaderDone}, if the deployment was a success.
     */
    ResourceLoaderDone load();
}
